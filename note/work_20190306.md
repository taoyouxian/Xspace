### final关键字用法

- 修饰类

```
当用final去修饰一个类的时候，表示这个类不能被继承。比如String类
注意：
a. 被final修饰的类，final类中的成员变量可以根据自己的实际需要设计为fianl。
b. final类中的成员方法都会被隐式的指定为final方法。
说明：在自己设计一个类的时候，要想好这个类将来是否会被继承，如果可以被继承，则该类不能使用fianl修饰，在这里呢，一般来说工具类我们往往都会设计成为一个fianl类。在JDK中，被设计为final类的有String、System等。
```

- 修饰方法

```
被final修饰的方法不能被重写。
注意：
a. 一个类的private方法会隐式的被指定为final方法。
b. 如果父类中有final修饰的方法，那么子类不能去重写。
```

- 修饰成员变量

```
注意：
a. 必须初始化值。
b. 被final修饰的成员变量赋值，有两种方式：1、直接赋值 2、全部在构造方法中赋初值。
c. 如果修饰的成员变量是基本类型，则表示这个变量的值不能改变。
d. 如果修饰的成员变量是一个引用类型，则是说这个引用的地址的值不能修改，但是这个引用所指向的对象里面的内容还是可以改变的。
```

### static关键字用法
注意：从JVM的类加载机制的角度讲，静态资源是类初始化的时候加载的，而非静态资源是类new的时候加载的
1. 被static修饰的变量属于类变量，可以通过类名.变量名直接引用，而不需要new出一个类来（static是不允许用来修饰局部变量）
2. 被static修饰的方法属于类方法，可以通过类名.方法名直接引用，而不需要new出一个类来（另外记住，即使没有显示地声明为static，类的构造器实际上也是静态方法。）
3. 静态块

	```
	静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问。
	静态资源的加载顺序是严格按照静态资源的定义顺序来加载的
	静态代码块是严格按照父类静态代码块->子类静态代码块的顺序加载的，且只加载一次。
	```
4.  如果static要修饰一个类，说明这个类是一个静态内部类


### [JUC——线程同步辅助工具类（Semaphore，CountDownLatch，CyclicBarrier）](https://www.cnblogs.com/itermis/p/9004041.html)

**CountDownLatch与CyclicBarrier的区别**：

- **CountDownLatch**最大的特征是进行一个数据减法的操作等待，所有的统计操作一旦开始之中就必须执行countDown()方法，如果等待个数不是0，就被一直等待，并且无法重置。
- **CyclicBarrier**设置一个等待的临界点，并且可以有多个等待线程出现，只要满足了临界点就触发了线程的执行代码后将重新开始进行计数处理操作，也可以直接利用reset()方法执行重置操作。



**Semaphore**通常用于限制可以访问某些资源（物理or逻辑）的线程数目。

https://www.cnblogs.com/dolphin0520/p/3920397.html

```
1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：
CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；
而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；
另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。
2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。
```



## [String、StringBuffer、StringBuilder](https://www.cnblogs.com/dolphin0520/p/3778589.html)

- String

  对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象

**StringBuilder**和StringBuffer类拥有的成员属性以及成员方法基本相同，区别是StringBuffer类的成员方法前面多了一个关键字：synchronized，不用多说，这个关键字是在多线程访问时起到安全保护作用的,也就是说**StringBuffer是线程安全**的。

```
1）对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；
　 如果作用于引用类型的变量，则比较的是所指向的对象的地址
2）对于equals方法，注意：equals方法不能作用于基本数据类型的变量
   如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；
   诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。
```

```
   在前面一篇讲解关于JVM内存机制的一篇博文中提到 ，在class文件中有一部分 来存储编译期间生成的 字面常量以及符号引用，这部分叫做class文件常量池，在运行期间对应着方法区的运行时常量池。

　　因此在上述代码中，String str1 = "hello world";和String str3 = "hello world"; 都在编译期间生成了 字面常量和符号引用，运行期间字面常量"hello world"被存储在运行时常量池（当然只保存了一份）。通过这种方式来将String对象跟引用绑定的话，JVM执行引擎会先在运行时常量池查找是否存在相同的字面常量，如果存在，则直接将引用指向已经存在的字面常量；否则在运行时常量池开辟一个空间来存储该字面常量，并将引用指向该字面常量。

　　总所周知，通过new关键字来生成对象是在堆区进行的，而在堆区进行对象生成的过程是不会去检测该对象是否已经存在的。因此通过new来创建对象，创建出的一定是不同的对象，即使字符串的内容是相同的。
```

